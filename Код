//Подготовил Абдугалиев Алмас. 27.03.2020. Класс основ криптографии КазНИТУ.
#include <iostream>
#include <vector>
#include <bits/stdc++.h>
using namespace std;

//Нам потребуется два основных метода. Первый это голосование по сдвигу ключей. Второй - это метод самого сдвига.
bool maj(bool x, bool y, bool z);
void rotation(vector<bool> v, bool last);


int main()
{
//Я задал случайный исходный текст сообщения с помощью сайта random.org
    vector<bool> plain_text{1,0,0,1,0,1,0,1, 
                            1,0,1,0,0,1,1,0, 
                            1,0,1,1,1,1,1,0, 
                            1,1,1,1,0,0,1,0, 
                            0,0,0,0,0,0,1,1, 
                            0,1,1,0,1,0,1,0, 
                            1,0,0,1,1,0,1,0, 
                            1,1,1,1,0,1,1,0 };

//Здесь мы выводим сообщение, чтобы потом сравнить его после расшифровки.
    cout << "Изначально текст имеет вид:";
    for (int x : plain_text) cout << x;
    cout << '\n';

//А это ключ. Три отдельных вектора изображающие циклы для сдвига. Они имеют размеры 19, 22 и 23 соответственно, 
//что в общем составляет длину ключа 64. Изначально все заполнены единицами, чтобы облечгчить поиск ошибок
//и продемонстрировать работоспособность.
    vector<bool> x(19, 1);
    vector<bool> y(22, 1);
    vector<bool> z(23, 1);

//Эти три вектора будут использоваться при расшифровке, так как первые три будут 
// подвергнуты изменениям при сдвиге на зашифровке
    vector<bool> xd(19, 1);
    vector<bool> yd(22, 1);
    vector<bool> zd(23, 1);

//Этот цикл предназначен для зашифровки сообщения. Зашифрованное сообщение будет записано в тот же вектор.
    for (int i = 0; i < plain_text.size(); i++) {

//здесь мы определяем наш бит голосования. maj означает majority - большинство.
        bool m = maj(x[8], y[10], z[10]);

//Здесь я определил биты для установки на первое место каждого цикла. ^ - это операция сумма по модулю 2
        bool r1 = (x[18] ^ x[17]) ^ (x[16] ^ x[13]);
        bool r2 = y[21] ^ y[20];
        bool r3 = (z[22] ^ z[21]) ^ z[20];

//Теперь надо сдвинуть циклически те векторы, которые побеждают в голосовании
        if (x[8] == m) rotation(x, r1);
        if (y[10] == m) rotation(y, r2);
        if (z[10] == m) rotation(z, r3);

//Теперь мы определяем наш бит для ключа той же операцией суммы по модулю 2,
//берем последние элементы каждого вектора
        bool res = (x[18] ^ z[21]) ^ y[23];


//Сумма по модулю 2 с исходным текстом.
        plain_text[i] = plain_text[i] ^ res;

//Цикл повторяется по полной длине сообщения
    }


//Вывожу зашифрованный текст. Из-за ключей с единицами на всех битах
//Зашифрованный текст обратный исходному
    cout << "Текст зашифрованный имеет вид:\n";
    for (int x : plain_text) cout << x;
    cout << '\n';


//Начинаю расшифровку. Алгоритм абсолютно тот же, при условии
    for (int i = 0; i < plain_text.size(); i++) {

        bool m = maj(xd[8], yd[10], zd[10]);

        bool r1 = (xd[18] ^ xd[17]) ^ (xd[16] ^ xd[13]);
        bool r2 = yd[21] ^ yd[20];
        bool r3 = (zd[22] ^ zd[21]) ^ zd[20];

        if (xd[8] == m) rotation(xd, r1);
        if (yd[10] == m) rotation(yd, r2);
        if (zd[10] == m) rotation(zd, r3);

        bool res = (xd[18] ^ zd[21]) ^ yd[23];

        plain_text[i] = plain_text[i] ^ res;

    }

//Вывожу расшифрованный текст
    cout << "Расшифрованный текст такой: \n";
    for (int x : plain_text) cout << x;
    cout << '\n';

    return 0;
}

//Логика голосования большинства взята с Википедии
bool maj(bool x, bool y, bool z) {
    bool res = ((x & y) | (x & z)) | (y & z);
    return res;
}


//Циклический сдвиг принимает вектор для сдвига и элемент для вставки в начале
void rotation(vector<bool> v, bool last) {
    for (int i = 1; i < v.size(); i++) {
        v[i] = v[i - 1];
    }
    v[0] = last;

    return;
}
